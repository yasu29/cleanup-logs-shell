#!/bin/bash

# ---- PATH 固定（cron 対策） --------------------------------------------------
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
export PATH

###############################################################################
# スクリプト名  : cleanup_logs.sh
# 概要          : 運用シェル用テンプレ（C用）
#                - ログ出力
#                - エラー時即終了
#                - 引数チェック
#                - 二重起動防止
#                - dry-run対応（変更処理の事前確認）
###############################################################################

# ---- 安全装置 ---------------------------------------------------------------
# -e : コマンド失敗時に即終了
# -u : 未定義変数使用時に即終了
# -o pipefail : パイプ途中の失敗も検知
set -euo pipefail

# ---- exit code 定義 ---------------------------------------------------------
EXIT_OK=0              # 正常終了
EXIT_GENERAL_ERROR=1   # 一般的な処理エラー
EXIT_INVALID_ARGS=2    # 引数不正
EXIT_LOCKED=3          # 二重起動検知

# ---- 基本情報 ---------------------------------------------------------------
SCRIPT_NAME=$(basename "$0")
BASE_DIR=$(cd "$(dirname "$0")" && pwd)

LOG_DIR="${BASE_DIR}/log"
TMP_DIR="${BASE_DIR}/tmp"
#CONF_DIR="${BASE_DIR}/../conf"

LOG_FILE="${LOG_DIR}/${SCRIPT_NAME}_$(date +%Y%m%d).log"
LOCK_FILE="${TMP_DIR}/${SCRIPT_NAME}.lock"

# ---- ログ出力関数 ------------------------------------------------------------
log() {
  echo "$(date '+%F %T') [$SCRIPT_NAME] $1" | tee -a "$LOG_FILE"
}

# ---- エラー終了関数 ----------------------------------------------------------
error_exit() {
  log "ERROR: $1"
  exit "${2:-$EXIT_GENERAL_ERROR}"
}

# =============================================================================
# 二重起動防止
# =============================================================================
if [ -e "$LOCK_FILE" ]; then
  error_exit "二重起動を検知したため処理を中断します" "$EXIT_LOCKED"
fi

touch "$LOCK_FILE"
trap 'rm -f "$LOCK_FILE"' EXIT ERR INT

log "ロック取得完了"

# =============================================================================
# 引数解析・妥当性チェック
# =============================================================================

# 引数数チェック
if [ "$#" -lt 2 ]; then
  error_exit "引数が不足しています。使用法: $SCRIPT_NAME <target_dir> <days> [dry-run|execute]" \
    "$EXIT_INVALID_ARGS"
fi

# 引数の割り当て
TARGET_DIR="$1"
DAYS="$2"
MODE="${3:-dry-run}"

# 対象ディレクトリ存在チェック
[ ! -d "$TARGET_DIR" ] && error_exit "対象ディレクトリが存在しません: $TARGET_DIR"

# DAYS が数値かチェック
case "$DAYS" in
  ''|*[!0-9]*) error_exit "日数は数値で指定してください: $DAYS" ;;
esac

# MODE 妥当性チェック
case "$MODE" in
  dry-run|execute)
    ;;
  *)
    error_exit "MODE は dry-run または execute を指定してください"
    ;;
esac

# =============================================================================
# 実行前準備
# =============================================================================

# ログ・一時ディレクトリを作成
mkdir -p "$LOG_DIR" "$TMP_DIR" \
  || error_exit "ログ／一時ディレクトリの作成に失敗しました"

# =============================================================================
# dry-run 判定
# =============================================================================
# dry-run とは：
# ・実際の「変更処理」は行わない
# ・処理対象の抽出、判定、ログ出力は行う
# ・本番実行前の安全確認を目的とする
#
# 使用例：
#   ./cleanup_logs.sh <target_dir> <days> [dry-run|execute]
# =============================================================================

if [ "$MODE" = "dry-run" ]; then
  log "dry-run モードで実行します（削除は行いません）"
elif [ "$MODE" = "execute" ]; then
  log "execute モードで実行します（削除を行います）"
else
  # 通常ここには来ない（妥当性チェック済みのため）
  error_exit "不正な実行モードです: $MODE"
fi

# ---- 処理開始 ---------------------------------------------------------------
log "処理開始"
log "MODE=${MODE}"
log "TARGET_DIR=${TARGET_DIR}"
log "DAYS=${DAYS}"

# =============================================================================
# メイン処理
# =============================================================================

###############################################################################
# 削除対象ファイルの抽出
###############################################################################

# find コマンドの結果（1行=1ファイル）を配列 DELETE_FILES に格納する
# 配列として受け取ることで、ファイル名に空白や特殊文字が含まれても
# 安全に後続処理（dry-run / 削除処理）を行える
mapfile -t DELETE_FILES < <(
  find "$TARGET_DIR" -type f -mtime +"$DAYS"
)

# 削除対象が1件も存在しない場合は、処理不要として正常終了する
# 不要な処理やログ出力を避けるため、ここで終了する
if [ "${#DELETE_FILES[@]}" -eq 0 ]; then
  log "削除対象ファイルはありません"
  exit 0
fi

log "削除対象件数: ${#DELETE_FILES[@]}"

if [ "$MODE" = "dry-run" ]; then
  for f in "${DELETE_FILES[@]}"; do
    log "[dry-run] 削除対象: $f"
  done
else
  for file in "${DELETE_FILES[@]}"; do
    if rm -f "$file"; then
      log "削除完了: $file"
    else
      error_exit "削除失敗: $file"
    fi
done
fi

# ---- 正常終了 ---------------------------------------------------------------
log "処理正常終了"
exit "$EXIT_OK"

